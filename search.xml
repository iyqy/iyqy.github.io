<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title></title>
      <url>http://qianyu1996.com/2017/09/17/fxbgye/</url>
      <content type="html"><![CDATA[<hr>
<p>title:  ��ҵ��������: 2017-07-07 16:12:41<br>tags:<br>����</p>
<p>�������ӣ�<a href="http://www.jianshu.com/p/f4f0c2dafffb" target="_blank" rel="external">http://www.jianshu.com/p/f4f0c2dafffb</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[携程火车票模块需求深挖]]></title>
      <url>http://qianyu1996.com/2017/06/05/xclx/</url>
      <content type="html"><![CDATA[<p>目标：通过对产品思考、结合用户调研，验证产品的合理性同时分析存在问题，并为下一次迭代做好准备。</p>
<p>产品基本情况：<br>【定位】<br>  一款满足常见订票需求、收取费用的自动查询预订火车票的软件，可以实时监控票数的多少，与铁道部数据实时同步</p>
<p>【优势】依托于携程旅行带来的巨额流量，携程火车票更容易满足在携程购买旅游产品等特定场景下有购票需求的用户，与公司其他产品形成闭环，助力于携程提供一站式出行服务。同时，依托于携程庞大的服务团队呼叫中心以及BD团队，携程火车票提供高质量服务的同时也能有很稳定的渠道保障，带来更安全、更方便、更省心的用户体验。<br><a id="more"></a><br>【劣势】产品较为受国家政策的影响、依赖于火车票互联网唯一分销商数据（12306），致使产品优化存在瓶颈。同时，以二级入口的形态存在的携程火车票在享有场景带来流量的同时，一定程度上损失了部分有单一垂直需求的购票用户（后者携程已并购智行、铁友火车票…完美）</p>
<p>【基本商业模式】技术型产品，利用商务团队获得各铁路部门的数据接口，结合携程的算法，提供给体验更好的购票服务，同时售卖保险产品，从中获取服务利润。（从身边同学的体验来看，推测是保险产品为大头的利润，不过师兄有数据还是以数据统计出来的为准）</p>
<p>【市场规模】<br>1.IT通过桔子得知携程于15年并购智行火车票1亿，可通过各大投资机构对相应市场的投资力度侧面反映出市场的火爆程度。<br>2.由易观智库的数据得知未来铁路出行人次将一直保持增长的势头。<br>中国在线火车票预订市场专题研究报告<br>（url）<br>3.通过替换变量，随着中国高铁的进步、国家经济的发展，旅游、商务等所拉动的出行市场必然是个朝阳行业<br>（能力有限，0岁PM初步认知市场通过这三个方式——资本数据层面、规模数据、替换变量侧面了解）</p>
<p>【主要版本迭代记录】</p>
<ul>
<li>v4.2 (2013-02-01) 【火车票】国内机票、高铁动车票订单支持取消订单功能；</li>
<li>v4.4 (2013-04-22)【火车票】全面支持普通车次预订，满足您更多出行需求;</li>
<li>v4.5 (2013-06-09) 【火车票】支持在线退票服务；支持支付宝，付款更方便;</li>
<li>v5.3 (2014-01-15)【火车票】火车可订儿童票啦，爸爸快带我去旅行！</li>
<li>v5.4.2 (2014-04-10)【火车票】微信支付，多种支付方式任你选;</li>
<li>v5.8 (2014-08-14)【火车票】支持国际火车票预订;</li>
<li>v5.9 (2014-09-18)【火车票】支持国际火车票通票预订；</li>
<li>v5.10 (2014-10-20)【火车票】欧铁通票预订，让你畅享欧陆风情； </li>
<li>v6.0.1 (2014-12-09)【火车票】优化上车补票，优化查询日历;</li>
<li>v6.2.0 (2015-02-06)【火车票】一键推荐汽车票；</li>
<li>v6.3.0 (2015-03-20)【火车票】支持在线改签票，出行自由又快捷;</li>
<li>v6.4.0 (2015-04-24)【自由行】支持打包火车票+酒店产品；</li>
<li>v6.5.0 (2015-05-21)【火车票】支持送票上门、学生票预订；</li>
<li>v6.6.0 (2015-06-25)【火车票】支持余票监控、捡漏票、私人定制票;</li>
<li>v6.7.0 (2015-07-28)【火车票】火车票也能私人订制，指定座位不再是梦；</li>
<li>v6.8.0 (2015-08-27)【火车票】独家开放高铁动车“真”选座，想坐哪就坐哪；</li>
<li>v6.9.0 (2015-09-28)【火车票】国内火车票可改签，台铁预订全新上线；</li>
<li>v6.10.2 (2015-11-05)【火车票】全面支持极速云抢票，全自动，更省心；</li>
<li>v6.11.0 (2015-11-18)【火车票】支持多车次抢票，全自动，成功率更高；</li>
<li>v6.12.1 (2015-12-21)【火车票】第八代超人抢票引擎，全力以赴帮您回家；</li>
<li>v6.16.0 (2016-05-20)超值套餐、票价立减，更有抢票超智能推荐；</li>
<li>v6.19.0 (2016-08-17)【火车票】抢票3.0，支持抢学生票、全新预约抢票;</li>
<li>v6.20.0 (2016-09-23)【火车票】绑卡后，可以不付钱先抢票啦；</li>
<li>v6.21.0 (2016-11-08)【火车票】中转站新上线，智能推荐中转方案；</li>
<li>v7.0.2 (2017-01-09)【火车票】先抢票后付钱，全力以赴，帮您回家；</li>
</ul>
<p>从以上迭代过程可以看出，在V6.0之前所做的迭代都是针对用户的基本订票需求来做出努力，可以说是一款能解决基本问题的MVP。<strong>V6.0之后根据产品发展的模型“三向模型”来进行规划，如：</strong><br>垂直场景下的需求深挖：支持在线改签票、送票上门等。<br>横向上的需求拓展：一键推荐汽车票；购买汽车票等。<br>拓展场景前后的需求：推荐购买保险；接火车送火车服务；行李寄送等。</p>
<p>【用户评价】<br>1.对核心功能云抢票十分满意，正向评价居多。</p>
<p>2.对于客服服务的态度较为满意。</p>
<p>用户群：<br>用户特征维度：<br>人口属性：青少年、大学生、中年、老年<br>心理特征：注重安全性、注重效率、注重可能性、贪小便宜、懒惰等<br>职业：学生、白领、体制内员工、外来务工者、自由职业者、商务人员、企业主等</p>
<p>场景维度：<br>春运等节假日抢票、商务出行前、商务出行中、旅游出行前、旅游中途、固定时间探亲、火车晚点、帮同事买票等一切与买票有关的场景</p>
<p>根据以上所罗列的一些特征与场景，<strong>我们可以根据场景频繁度高或者用户基数大的一些情况进行需求分析与需求深入挖掘、拓展（结合后台数据判断），如此挖掘需求点以给用户带来最大程度的满意以及产品的收益。</strong></p>
<p>当然在分析之前我们不能忘了产品在这个阶段，通过咨询公司买来的、或通过大量调研验证、VC机构看好的最最<strong>核心的痛点</strong>，比如共享单车-解决最后一公里，滴滴-低价高效的打到车。<br>火车票产品的用户痛点在于：<strong>能否高效帮我解决长途出行问题</strong>（我个人认为任何需求都不能以牺牲核心需求来做优化，所有服务如云抢票、国际火车票、路线推荐等都是在高效、解决出行问题的基础上做优化）</p>
<p>举个例子：<br>显而易见，学生是互联网订票的主力军之一（如果不是最主要的用户群，那也是占比非常高的一类用户，这类用户的特征和其他用户在特征上有许多重合点，定量可结合产品前辈拿到的后台数据），<strong>他的需求涵盖了一款火车票产品很大一部分要实现的需求。</strong></p>
<p>【用户访谈】<br>目的：收集需求并分析，由此来粗略体验一下携程火车票迭代的合理性，同时挖掘一些有可能的价值点。</p>
<p>角色：<br>学生   年龄：22    性格特征： 注重安全、爱旅游、拖延症</p>
<p>通过对该同学的访谈得到了如下信息：<br>【订票方式】大多数通过无线端12306订票、偶尔去车站订票。很少考虑其他的订票软件，原因为注册填写信息麻烦。</p>
<p>【使用场景】<br>放假回家，通过12306购票，通常买卧铺，在完成购票的过程中，利用下单又取消订单等方式来买到自己想要的下铺。对于改签的使用场景：放假时间改了、时间更早的车票出票了，可以更早回家。</p>
<p>【异常场景】<br>1.买不到票的时候怎么解决<br>换成第二天的票，或者等一段时间再去看看有没有人退票可以买。‘<br>买终点上一站的票，到火车上临时补票。<br>2.到终点后的场景<br>通过滴滴打车、公交车或者地铁的方式前往目的地</p>
<p>【槽点】<br>希望火车站开通支付宝支付，火车站买票不能用支付宝只能用银行卡，又通过12036不能购票（火车发车前某时间段12306将停止售票，而线下渠道仍然开通售卖服务）</p>
<p>比对携程迭代的各版本，V6.0后的大部分契合了这位同学垂直场景下的需求：<br>1.很少考虑其他购票软件因为注册填写信息麻烦——登陆可关联12306购票<br>2.等一段时间再去看看有没有人退票可以买——余票监控<br>3.通常买卧铺下铺——推出购买制定位置车票的功能<br>4.通过滴滴打车、公交车或者地铁的方式前往目的地——推出接送火车业务<br>5.买终点上一站的票，到火车上临时补票——智能推荐购票方案<br>6.希望火车站开通支付宝支付——未解决<br>7.时间更早的车票出票要改签——携程推出的改签功能</p>
<p>【需求分析】<br>因为此次用研的目的是验证携程火车票产品功能所对应的的需求可行性，所以没有过多去寻找不同特征的用户群来验证需求的强弱性以及实现难度来进行优先级排布。而后具体工作相信需要结合具体的pv、下单率等指标以及AB测试法来验证。这里针对第六点需求写一些自己的思考。</p>
<p>第六点要求火车站开通支付宝支付，当然携程作为一家下游订票平台，无法实现这样的需求，但是这里的需求并非为真正的需求。之前很强调一点就是不管如何都不能忘记最核心的痛点，能否高效帮我解决长途出行问题是火车票产品的核心，所以显然，要求火车站开通支付宝的目的无疑是想直接用支付宝高效的买到即将发车的车票，那携程能做些什么呢？让用户通过我们的产品买到即将发车的票。但是矛盾点在于12306作为分销商，火车发车前某时间段12306即停止售票，携程上也提供不了这种票的销售服务。PM看似要协调问题了，把问题反馈给12306？屯票是否有可能？或许要进行一场头脑风暴也许有解决的方案？ 也许意义不大，考虑到这个用研的样本小，而且就算能提供这种类的型票也不见得用户买账，低频弱需求实现成本明显高，PM不能做…</p>
<p>【竞品分析】<br>为模拟在真实情况下产品的使用，我采用<strong>实地观察</strong>观察的方式，让我的同学模拟下预定了去上海的火车票，我在边上看，他来叙述他的关注点<br>发现我同学作为用户来说，操作步骤都在集中在如下逻辑图之内：<br><img src="http://upload-images.jianshu.io/upload_images/5741130-3b678507654b3d90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="绘图1.png"><br>为了进一部分析火车票产品，我们拆解该模块：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5741130-e58345d62e43c873.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="火车票.png"><br>产品结构简单明了，底部导航栏四个Tab依次是“抢票”、“在线选座”、“订单”、“火车服务” 。产品核心的车票查询、购票、抢票功能展示在模块打开后的一级页面，清晰直观。</p>
<p>但为了保证核心功能展示层级高，多数功能隐藏至火车服务。用户找到“车站攻略”、“行李寄送”功能需要经过火车服务——行李寄送打开。根据携程后台的数据，可以考虑将部分服务展示层级提高，不仅仅是在二级页面展示。</p>
<p>######对比了同程旅游等其他产品最终给出的两点产品优化建议：<br>1：<br><img src="http://upload-images.jianshu.io/upload_images/5741130-61ad330075afed24.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="筛选功能.jpg"></p>
<p>在二级入口筛选车票功能模块，提供了出发、到站条件筛选，并且可以提供多选功能。体验过程中第一次看到这个筛选不是很理解是什么意思，对比同程旅行提供的筛选功能，同程将出发与到站两个筛选条件分别列举出来独占一定的区域让用户选择，清晰明了，让用户可快速选择到站、出站区，而携程火车票犯了低级错误，在条件选择上让用户感到纠结。无论是<strong>布局还是选择</strong>都产生了歧义——出发站点与到达车站选项想当然认为是左右布局，实际上是上下布局（上部分为出发车站，下部分为到达车站），选择方面我同时勾选了杭州东站与杭州站产生了歧义（系统会不会列出杭州东站送到杭州站的车票呢？）结合用户的实际使用场景，或者后台数据（<strong>在筛选界面停留的时间最为关键指标推出AB测试，如果确实能减少停留时间，引导用户更早的筛选出车票下单，那么我们这个优化就是有意义的。</strong>）</p>
<p>2：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5741130-01e9c9d782f32615.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="抢票功能.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5741130-9afb092df170ca64.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="终止时间.jpg"></p>
<p>在实际使用抢票功能时我们有一种常见的场景，也是本人真实遇到过的问题——我准备今天去上海，但是车票已经售完了，所以我试试看抢票功能，让它一直帮我监控着，有的话就帮我下单吧，<strong>结果在快要发车的时候携程帮我抢到的票，可是我家离车站很远啊赶不过去，退票的话又要扣除手续费！</strong> 这里就有一个抢票时间设定的问题——<strong>用户可自由设置抢票终止时间，如果在这个时间段没有抢到票就停了吧，我买明天的票</strong>，而携程提供默认的抢票终止时间是随机的，若是这样则会是用户遭遇如上尴尬的使用场景，建议在抢票信息填写信息提示一栏可抢票时间段可设置（考虑到余票监控需要占用服务器大量资源，携程设置的终止抢票时间必然是通过当前服务器资源等利用算法做判断生成的，<strong>所以我们可以让用户仅有将终止抢票时间提前的权利，这样子既避免了用户尴尬场景优化用户体验，还一定程度上减少了服务器资源成本提高收益</strong>）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[美甲行业用户访谈报告]]></title>
      <url>http://qianyu1996.com/2017/05/12/mj/</url>
      <content type="html"><![CDATA[<h2 id="调研背景及目的"><a href="#调研背景及目的" class="headerlink" title="调研背景及目的"></a>调研背景及目的</h2><ul>
<li><p>调研目的<br> 乙方提出互联网+美甲服务的需求，希望将部分服务上线，为了更精准的理解用户需求，完成小程序外包服务，本人决定走访美甲用户得深入分析。</p>
</li>
<li><p>调研方式<br>采取用户访谈形式，探索性调研。访谈人数共计三人，访谈用时合计100分钟</p>
<a id="more"></a>
<h2 id="用户画像："><a href="#用户画像：" class="headerlink" title="用户画像："></a>用户画像：</h2><p>| 职业       | 年龄|性别           | 收入 |<br>| ——— |:————-:| :—–:|—–:|<br>| 甲：学生               | 20   |女 | ￥1500 |<br>| 乙：事业单位白领  | 26| 女   |   不详 |<br>| 丙：服装店老板| 不详  |女  |    不详 |</p>
</li>
</ul>
<h2 id="访谈内容展现"><a href="#访谈内容展现" class="headerlink" title="访谈内容展现"></a>访谈内容展现</h2><ul>
<li><p>平时关注互联网吗？关注哪类咨询？怎么获取美甲相关信息呢？<br>  甲：<br>关注，我会关注旅游、健康护理、文学方面的，平时看新闻用今日         头条比较多，美甲的话我偶尔想做了会去贴吧啊找一些好看的图片，微博上也有相关的博主，会经常推送一些好看的美甲图片。</p>
<p>  乙：<br>关注，平时一般都看些电视剧、动漫、游戏方面的方面的，不怎么关注美甲相关的信息，周围看到朋友做了不错的美甲一般就会去问别人是哪家做的，然后自己去找店家。</p>
<p>  丙：<br>关注，关注美容、护肤、健康饮食、服装方面的一些东西，微博上、公众号上有关注一些美甲大V，他们会经常推送一些好看的美甲图片，有推送了一般都能看得到。一天有70%多的时间花在手机上面。</p>
</li>
<li><p>如何选取美甲店：<br>  甲：<br>美团、大众点评等评价较高的美甲店，周围朋友、同学推荐，美甲服务，服务质量好，下次就会去同一家。</p>
<p>  乙：选择和单位比较近的，朋友推荐有时候会推荐一些美甲店，自己有空的时候会专门去美甲店做个美甲，感觉美甲店服务都差不多。</p>
<p> 丙：出去逛街啊，发现有啊！美甲店面会偶尔进去逛逛，选取美甲店的主要因素是价格。</p>
</li>
<li><p>动机：<br>甲：<br>在新浪微博、贴吧等社区看到不错的美甲形状，带上图片寻找美甲师美甲。看到周围朋友做出一个漂亮的指甲，询问美甲地点，和其他朋友结伴去美甲店。</p>
<p>乙：<br>美甲坏了会专门去就近的美甲店做个美甲，周围朋友做了不错的美甲也会向我推荐一下。</p>
<p>丙：<br>逛街的时候看到有些装修不错的美甲店会进去看看，如果觉的价格不错的话会做一个美甲，就和平时逛服装店的形式差不多。</p>
</li>
<li><p>关于付款：<br>甲：<br>通常来说采用现金支付或支付宝微信支付方式，一般不通过美团、大众点评等购券消费，因为美甲店增值服务较多，通常贴钻、所选取形状的难易程度都能较大程度上影响价格，美团下单价格并非最终价格，结束美甲服务后通常都会为一些增值服务埋单。</p>
<p>乙：<br>通常来说采用现金支付或支付宝微信支付方式</p>
<p>丙：<br>会问问店家能否使用美团上的券啊，如果可以使用就会美团下单，通常是支付宝或者微信支付。</p>
</li>
<li><p>美甲周期：<br> 甲：<br>一般来说指甲脱落的时间为一个月左右，若在美甲后一周内脱落，可去美甲店免费补甲，但脱落了也不会专程跑一趟去补甲，主要看自己有没有时间。</p>
<p> 乙：<br>指甲长出来一般就会换，一到两个月左右。</p>
<p>丙：<br>指甲店有免费的服务，可以把你做的美甲给去除，要是觉得不好看就会过去换了，通常来说一个月回去换一次美甲。</p>
</li>
</ul>
<ul>
<li>美甲流程：<br>1.进店根据提供的样板图选取颜色卡，选取美甲形状，选取美甲材料种类（QQ甲、涂料粉等），选择贴钻种类，美甲客户也可以自己携带相关的美甲图片给美甲师，美甲师根据难度来给出美甲服务的价格。<br>2.美甲阶段，修建指甲，修建死皮，擦拭护手霜，指甲上色，美甲机烘干指甲。<br>3.美甲结束拍照留存</li>
<li><p>美甲店周边服务：<br>出售面膜、护肤品等，一般不出售指甲油等品类，若出售指甲油会使消费者怀疑自己美甲时所使用的美甲油材料是否真实。</p>
</li>
<li><p>美甲过程需要一个多小时，这期间干些什么事：<br>甲：<br>主要是玩手机啊，有些美甲店装修比较好，有电视电影可以看，或者实在 没事的话和老板瞎聊聊。</p>
<p>乙：<br>和老板聊天，看着美甲师做美甲啊。</p>
<p>丙：<br>会看看一些不错的美甲图片，和美甲师聊聊天，因为是两只手同时再做美甲，所以没有办法玩手机。</p>
</li>
</ul>
<ul>
<li><p>平时是否关注美业相关信息：<br>甲：<br> 一般通过微博、贴吧看看一些美甲的效果图，频次不高，不会主动去关注此类的信息，美甲教程不怎么关注，和朋友间相关美甲的话题也不怎么提及。</p>
<p>乙：<br>不主动关注，一般都是去了店里选择美甲的形状做美甲</p>
<p>丙：<br>会啊，关注了一些微信公众号，会推送一些好看的美甲图片，自己也会主动去关注一些美甲方面的视频教程。</p>
</li>
</ul>
<ul>
<li><p>平时会不会自己动手美甲：<br>甲：<br>不会，网络上有很多教程自己平时也不怎么关注，但是自己动手的话很容易把指甲画残，又花时间又花精力，得不偿失。但是有些朋友会关注这方面的，自己动手涂指甲，但那种只是简单的涂指甲油，和美甲比起来效果有很大差距。关于用的指甲油，一般通过礼品店购买，淘宝上偶尔也会购买相关产品。</p>
<p>乙：<br>平时会去一些礼品店买一些指甲油什么的自己涂，因为美甲需要很多的工具，自己也不太会去弄，又比较花时间。</p>
<p>丙：<br>不会，一般来说去美甲店直接做，不会自己去做美甲。</p>
</li>
<li><p>有关服务不满意的地方：<br>甲：<br>节假日美甲人数很多，排队人数很多，浪费时间较多。要是能提高排队效率就好了。同时挺希望有个上门服务的美甲店，我们宿舍，我的朋友们在一起想做一个美甲，大家一起叫一个美甲师来我家，尽管费用高一点，我也比较希望会有这么一种服务~</p>
<p>乙：<br>没有，感觉都挺好的</p>
<p>丙：<br>希望美甲店的价格能够再低一点，服务方面都挺好的~</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>1.排队人数多，浪费太多的时间<br>2.平时比较懒，希望有上门服务<br>3.希望美甲的费用再低点<br>4.平时会关注一些美甲图片、教程<br>5.商家需要推出会员服务</p>
<p>对应需求结合小程序形态拟推出如下功能：<br>预约、美图展示（美甲用户、商家都可展示）、美图分享、会员<br>上门服务（舍弃）、美甲教程（舍弃）</p>
<p>##产品结构图<br><img src="http://upload-images.jianshu.io/upload_images/5741130-1017171d59b1f006.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="美业小程序"></p>
</li>
</ul>
<p>  ##产品原型<br><a href="https://modao.cc/app/FtiUsTTdACWZWZVKMO5SLML7gpGptjd" target="_blank" rel="external">低保真原型</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>   结合小程序即用即走的产品特征，以及具体的使用场景，预约是优先级最高的用户痛点，预约功能也将是小程序最主要的功能点。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[小程序界面设计规范]]></title>
      <url>http://qianyu1996.com/2017/05/05/xcx/</url>
      <content type="html"><![CDATA[<ul>
<li>减少无关的设计元素对用户目标的干扰</li>
<li>去掉任何与用户目标不相关的内容，明确页面主题</li>
<li>区分操作主次，减轻用户的选择难度</li>
<li>避免出现用户目标流程之外的内容而打断用户<a id="more"></a></li>
<li><p>导航明确，来去自如，切勿增加用户学习成本或改变使用习惯<br>小程序导航栏分为导航区域、标题区域以及操作区域，颜色为深浅两种</p>
<p>Android：导航区仅存在唯一操作×，直接退出小程序。当用户通过操作区的<br>菜单将小程序添加至安卓桌面，并从安卓桌面打开小程序时，小程序的首页，不展示导航按钮。仅展示小程序标题和操作区。小程序次级页面，导航区只有返回上一级页面的操作</p>
<p>IOS：微信进入小程序的第一个页面，导航区通常只有一个操作——“返回”，即返回进入小程序前的微信页面。 进入小程序后的次级页面，导航区的操作为——“返回” 和“关闭”。 “返回”，即返回上一级小程序界面或微信界面。“关闭”，即在当前界面直接退出小程序，回到进入小程序前的微信页面。</p>
</li>
<li>减少等待，反馈及时</li>
<li>微信小程序内，使用微信提供标准的页面下拉刷新加载能力和样式</li>
<li>页面内加载反馈</li>
<li>谨慎使用模态加载（模态的加载样式将覆盖整个页面的）</li>
<li>局部加载反馈（类似于ajax）</li>
<li>页面局部操作结果反馈、页面全局操作结果——弹出式提示（Toast）、页面全局操作结果——模态对话框、页面全局操作结果—结果页</li>
<li>异常可控，有路可退（表单报错，在表单顶部告知错误原因，并标识出错误字段提示用户修改）</li>
<li>减少输入（摄像头识别银行卡号、地理位置接口）</li>
<li>避免误操作（如增加大热区）</li>
<li>利用接口提升性能（信设计中心已推出了一套网页标准控件库，包括 <a href="https://wximg.gtimg.com/shake_tv/mina/WEUI_1_0_161226_Sketch.zip" target="_blank" rel="external">sketch设计控件库</a> 和 <a href="https://wximg.gtimg.com/shake_tv/mina/WeUI1.0.psd.zip" target="_blank" rel="external">Photoshop设计控件库</a>，后续还将完善小程序组件）</li>
<li>同意稳定性，统一的页面体验和有延续性的界面元素都将帮助用最少的学习成本达成使用目标</li>
<li>视觉规范：<br><img src="http://upload-images.jianshu.io/upload_images/5741130-a729dea5f628a2c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/5741130-b913f23ac38fc4d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/5741130-b7d395f86f619042.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/5741130-fdc20b3cee6bc3b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/5741130-2b32da78e8d96f06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/5741130-1eaf4b2d38543237.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/5741130-42da1ab560b0a310.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/5741130-56b815ed77476d81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/5741130-3a2532d0eac4203b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/5741130-8a46f2a898c9bb79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/5741130-55dec02e23d63077.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>组件库<br><a href="https://mp.weixin.qq.com/debug/wxadoc/design/#资源下载" target="_blank" rel="external">微信小程序组件仓库</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[知乎随记]]></title>
      <url>http://qianyu1996.com/2017/04/05/zhsj/</url>
      <content type="html"><![CDATA[<ul>
<li>PM根据产品所处的阶段阶段性的选择设计方案：</li>
<li>NPS：净推荐值，客户忠诚度指标（推荐值减去批评值）</li>
</ul>
<p>初期阶段，跨越鸿沟，关注小白用户，主推优化核心功能（定义基础交互、定义视觉方案、优化关键路径）</p>
<ul>
<li>标签式交互：适用于5个以下的标签、每个使用频率都比较高，适合geek用户去探索发现新功能</li>
<li>抽屉式交互：灵活性较高、让用户聚焦于当前交互内容<a id="more"></a>
</li>
</ul>
<ul>
<li><p>模块拆解思维（模块拆分思维的重要性）</p>
</li>
<li><p>传统行业和互联网还有哪些机会？<br>都是机会，信息对称，提升效率的（让商品和服务更加便捷），优化流程<br>，满足新需求提高用户的生活效率，差异化个性化用户反馈即使迭代（非品牌化、定制化）</p>
</li>
</ul>
<ul>
<li>o2o虚拟数字世界和显示世界互动的新的商业模式。<br>本质上：个性化内容+碎片化营销=各式精准互动的社会化营销（渠道与流量的整合），生活服务互联网化最重要的是数据的整合，为碎片化的决策消费和碎片化的享受消费提供战略依据</li>
</ul>
<ul>
<li>数据分析，如何提供打点需求：次日留存、30日留存、月留存、新用户次日留存、pv uv。miui有很多数据分析后台</li>
</ul>
<h5 id="to-B和to-C的产品经理的区别"><a href="#to-B和to-C的产品经理的区别" class="headerlink" title="to B和to C的产品经理的区别"></a>to B和to C的产品经理的区别</h5><p>c：发现用户需求，定义用户价值，推动项目组达成这一目标。<br>b：根据公司战略或工作需要，构建生态系统，推动流程化，提高效率</p>
<p>c端 需要有一定的运营基础、数据分析基础、交互设计能力、用户体验感知<br>指标考核：dau pv uv 活跃用户、用户增长、营收相关指标</p>
<p>b端 需求梳理能力和个人推动能力<br>指标考核：系统建设、效率提升、工作能力进行指标建设</p>
<h5 id="关于用户访谈"><a href="#关于用户访谈" class="headerlink" title="关于用户访谈"></a>关于用户访谈</h5><p>1.市场上的：客户看到了什么，遭遇的问题？（产品所处的环境）<br>2.影响者：听到的什么？（他的朋友说什么，谁影响了他）<br>3.外在表现行为？（怎么做的）<br>4.最大的挫折：挖掘痛点<br>5.最关注的：真正的想法和感觉？（梦想，想要什么，产品什么是最重要的）<br>when 第一次买我们产品是什么时候？1<br>where 在哪儿买的？1<br>compare1 有考虑过其他产品吗？（用前感受）1<br>recognize 店员和你说什么？2<br>why 买了多少为什么？3<br>feel 用后感觉？45<br>time 用了多久？3<br>compare2 换过其他产品吗？（用后感受）4<br>situation 什么情况下换的？4</p>
<ul>
<li>通过用户访谈完善这张表：<br>精益创业实战：<br>产品层面：遇到的三个问题，解决方案，关键指标，独特卖点，成本分析<br>市场层面：门槛优势，渠道，客户群体分类，收入分析，收支平衡点</li>
</ul>
<ul>
<li>关于流量、转化率：<br>流量：<br>1.花钱买基本渠道<br>2.设置爆款诱饵<br>3.大平台换流量（线上平台、线下展会）<br>4.内部邀请引流<br>5.发展代理<br>转化率：<br>1公众符号背书（明星代言）<br>2.差异化效果<br>3.积分制度<br>4.过度宣传</li>
</ul>
<h5 id="关于直播模式："><a href="#关于直播模式：" class="headerlink" title="关于直播模式："></a>关于直播模式：</h5><p>秀场：<br>男色女色来吸引打造有需求的用户，挖掘高消费能力的用户<br>优点：变现快，流量现金运转良好<br>缺点：面临政策高压线，过度压榨用户<br>网易BOBO、YY、9158、炫舞、六间房</p>
<p>网红：<br>挖掘一批具有粉丝号召力良好素质的任务来带动平台流量<br>优点：流量增长快，转型难度低，受众相对单一潜力大<br>缺点：过度依赖高价值主播，容易向秀场转型<br>代表：映客、Me直播、花椒、一直播</p>
<p>平台：<br>输出高质量内容，如游戏直播、发布会、独特的才艺等<br>缺点：内容建造难度大<br>优点：可以支撑起整个平台内容的多样性<br>代表：斗鱼、虎牙、熊猫、花椒</p>
<p>场景（社群模式）：<br>依赖于场景入口，社群交流，基于目前社会环境下的一种新的社交语言或者形式<br>优点：快速找到共识的团体<br>缺点：模式不够成熟</p>
<p>即时社会交际仅能满足娱乐需求，对于人的发展没有任何作用，而传统社会交际形成的关系网则相反，我难以评价两种方式的优劣。</p>
<p>爱奇艺的发展：<br>百度投资爱奇艺，在百度搜索结果页展示爱奇艺网站入口，视频行业用户转移成本低</p>
<p>产品体验：<br>低网速借助于百度CDN布局保证了他的用户体验<br>高网速提供高清画质<br>补老片资源，建立起内容壁垒</p>
<p>爱奇艺主打电影电视剧，优酷则是UGC，爱奇艺收购pps客户端视频<br>正版长视频、强化自制剧、启动UGC业务。买下独播版权，不分销，暗示着自制也会提上日程</p>
<p>bilibili<br>1.抓牢了一批核心用户，聚焦起来一批ACG文化产品消费者的这一批核心用户</p>
<p>2.培养出来弹幕亚文化社群</p>
<p>3.合理的盈利机制：<br>1.没有会员体系（低龄用户并没有多少消费能力），承包制（这一年龄段的自我表现欲）<br>2.通过手游联运等衍生产品盈利</p>
<p>4.缺点没有建立动漫周边销售渠道，需要开发文化产品，观看交流消费没有形成闭环</p>
<h5 id="关于选取竞品："><a href="#关于选取竞品：" class="headerlink" title="关于选取竞品："></a>关于选取竞品：</h5><p>1.竞品，顾名思义，对你构成竞争威胁的产品，这里有个竞争对象，就是我们的用户。<br>选取竞品的特征（其中一个维度）：指标：用户群重合度。 用户占有率。这类指标比较难量化（），<br>结合用户画像。 提供相同或者相似的功能或者服务。（作为参考）</p>
<p>交互设计？<br>确定一个核心目标也就是任务，吧流程图和框架图画出来（所经过的每一步），<br>确保能否顺利走到目标。 结束后考虑优化<br>（是否需要一下其他帮助更好的达到目标？辅助功能、系统提示、便捷入口）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[怎么理解互联网思维]]></title>
      <url>http://qianyu1996.com/2017/03/01/hlwsw/</url>
      <content type="html"><![CDATA[<p>非常赞同信息化应用思维这一说法。<br>结合场景，将互联网思维运用到广义上的生产者，消费者身上：</p>
<h2 id="1-场景（个人异端化-互联网时代特征）"><a href="#1-场景（个人异端化-互联网时代特征）" class="headerlink" title="1.场景（个人异端化-互联网时代特征）"></a>1.场景（个人异端化-互联网时代特征）</h2><p>互联网思维：去中心化<br>也就是我们通常所说的web2.0时代，互联网的信息传递和获取比传统方式快了很多也更加丰富，信息获取更便捷。更重要的是，该场景让人们表达、表现自己成为可能——致使信息传播的关键节点不明确，没有所谓中心。<br><a id="more"></a></p>
<h2 id="2-消费者（用户为中心-非互联网时代特征）"><a href="#2-消费者（用户为中心-非互联网时代特征）" class="headerlink" title="2.消费者（用户为中心-非互联网时代特征）"></a>2.消费者（用户为中心-非互联网时代特征）</h2><p>互联网思维：情感要素<br>任何商业模式的根本都是消费者，都是让消费者满意，抓住他们的心。基于互联网产品的特性，用户体验被着重强调。产品层面出发的简约思维（产品规划、产品设计）、极致思维（服务），运营层面出发的情感思维（产品推广）——迎合用户在情感上、价值观上的需求。其目的在于提高用户体验，塑造更好的品牌形象进而联系到本质——抓住消费者的心。<br>        传统产品的设计推广其目的也如此，并不觉得它的思维很互联网化，如果非要说互联网特有的思维的话，那就是这个时代更加注重用户体验了吧。</p>
<h2 id="3-生产者（在该场景下用很互联网的方式去赢得消费者的心-互联网时代特征）"><a href="#3-生产者（在该场景下用很互联网的方式去赢得消费者的心-互联网时代特征）" class="headerlink" title="3.生产者（在该场景下用很互联网的方式去赢得消费者的心-互联网时代特征）"></a>3.生产者（在该场景下用很互联网的方式去赢得消费者的心-互联网时代特征）</h2><p>互联网思维：流量思维，数据思维，快速迭代<br>1.流量思维（经营模式）<br>互联网公司都有很典型的流量思维，“流量即入口”“流量即金钱”，而免费又是获取流量的一个很典型的方式，从没有哪个时代让我们享受如此之多的免费服务，所以流量思维必然是互联网思维里面的一个。<br>2.数据思维（数据驱动运营）<br>在该场景下，数据的搜集和获取更加便捷，并且随着大数据时代的到来，数据分析预测对于提升运营以及产品的设计有着非常重要的参考价值。<br>3.快速迭代（创新流程）<br>与传统产品相比，互联网没有产品库存，迭代周期短，你不一定知道用户真正想要的，只有快速、不断的迭代试错才能为客户提供更人性化的服务。这一特性注定了你要摒弃传统十年磨一剑的思维，互联网产品——谁先成功地推出产品谁就有更大的机会成为这一领域的老大；培养快狠精准的眼光，通过迭代升华内涵，这是个量变到质变过程。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[神汽在线产品分析报告（word）]]></title>
      <url>http://qianyu1996.com/2017/02/08/sqzx/</url>
      <content type="html"><![CDATA[<p></p><h3>体验环境</h3><br>体验产品：神汽在线Android版本<br>软件版本：Android v2.7.1<br>设备型号：华为荣耀7<br>操作系统：EMUI 4.0.1<p></p>
<p><a href="http://pan.baidu.com/s/1bMAXVS" target="_blank" rel="external">神汽在线产品分析报告（word）下载<a><br><a id="more"></a></a></a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[公众号、app推送消息的时间基于什么原则选择的？]]></title>
      <url>http://qianyu1996.com/2017/01/22/gzh/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/5741130-ccf8048d327c2583.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><a id="more"></a></p>
<p>##用户习惯</p>
<ul>
<li>正常人的生活习惯<br>一日三顿饭，夜里睡觉，节假日休息。 这样的特点决定了午饭后、睡觉前、节假日左右用户有空闲，是一个自然的小高峰。</li>
</ul>
<ul>
<li>目标用户的习惯<br><strong>新闻讯息类产品</strong>早上9-10点，下午5-6点的推送时段，是针对白领上班族的。和学生、蓝领是有一些区别的。如果倾向<strong>中老年人的产品</strong>，一般起得早，睡得早，时间习惯提前，可能对应7:30、21:00来推送相关消息。<strong>股票证券类产品</strong>，大A股开盘是9点一刻，那推送消息一般会提前30分钟。 <strong>理财类产品</strong>，会在标的开卖之前推送。用户群体不同，都是有一些轻微的不同的，这些点需要经验积累、做好用户调研才能找到最适合自己用户群的时间段。</li>
</ul>
<p>##竞争策略</p>
<ul>
<li>避开竞争<br>你11：30发我就11点发，你11点发，我就10：30发，10：30还是很多竞争对手发，那我晚上再发。这是有效的策略。新闻资讯类抢早（尤其是娱乐新闻），独家内容类宁可偏晚（确保竞争少，让用户一定看到）。</li>
</ul>
<ul>
<li>培养用户习惯<br>这是非常重要的一步，如逻辑思维创始人罗永浩在每天早晨7点钟会推送一条语音，又如十点读书、夜听之类的公众号名字起得就非常好，已经在暗示用户的阅读习惯了。保持同一个时间发文，不仅利于<strong>用户粘性</strong>的增加，也有利于打造独一无二的<strong>品牌价值</strong>。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[三部曲方法论]]></title>
      <url>http://qianyu1996.com/2016/11/22/idea/</url>
      <content type="html"><![CDATA[<p>描述需求 需求的最终状态–给定环境输入和输出<br>1.善用逻辑图（不同于流程图），需求子需求。用图形表达一个部分和另一部分的逻辑关系（并列，包含，基础等）keynote<br>2.思维导图拆解需求，需求-子需求—-表单设计，问题分解 测试用例，用例图<br>3.visio拆解流程，比如京东购物的行为，拆解成子流程（注册流程，加入购物车等等）<br>4。拆解UI和交互，得到axure原型 （线框图）<br><a id="more"></a></p>
<p>得到一组测试用例（产品，模块，功能，环境，输入，预期输出，实际输出），流程图，原型（或者线框图）</p>
<p>实现需求<br>1.mvp minimal viable product 核心业务逻辑已经跑通的情况最小可用产品雏形<br>2.寻找组织工具链–卖电子书（下单支付）–金数据 麦克斯扬MN，表单工具生成表单。<br>3.理解技术，会编程指的是mvp时工具链某些模块功能覆盖不到的。</p>
<p>项目管理<br>1.假设（基于一个假设来推荐项目）<br>2.同级别的，怎么按照你的想法来达成你的目标呢？善用契约-开会是种形式，为了定下一组契约，书面的东西更加正式<br>3.保持真诚，（同时注意说话的艺术）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[京东天猫app模块拆解]]></title>
      <url>http://qianyu1996.com/2016/11/20/page/</url>
      <content type="html"><![CDATA[<body><br><h1 align="center" class="root"><br><a name="tm">天猫APP</a><br></h1><br><a id="more"></a><br><h1 align="center">（ctrl+鼠标向前滚轮来查看图片）</h1><br><br><br><br><br><div align="center" class="globalOverview"><br><img src="http://occtjfc90.bkt.clouddn.com/img/%E5%A4%A9%E7%8C%ABAPP.jpg"></div><br><br><h1 align="center" class="root"><br><a name="tm">京东APP（ctrl+鼠标向前滚轮来查看图片）</a><br></h1><br><br><div align="center" class="globalOverview"><br><img src="http://occtjfc90.bkt.clouddn.com/img/%E4%BA%AC%E4%B8%9CAPP%202.jpg"></div><br></body>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[计算机组成原理]]></title>
      <url>http://qianyu1996.com/2016/09/11/zcyl/</url>
      <content type="html"><![CDATA[<p></p><h3>计算机系统概论</h3><br>1.什么是计算机系统，计算机硬件，计算机软件？<br>计算机系统分为计算机硬件和计算机软件两部分，所谓硬件指的是计算机看的见的物理元器件，如主机和各种外设<br>所谓软件指的是人们事先编好的程序，基于硬件部分，能够更好的利用分配资源，充分发挥硬件的功能。<p></p>
<p>2.如何理解计算机系统的层次结构？<br>一般分为五级结构，从底层到高级部分依次为：微程序机器（硬件直接执行微指令）-机器语言机器（微程序解析机器指令）-<br>操作系统虚拟机（机器语言解释操作系统）-汇编语言虚拟机（汇编语言翻译成机器语言）-高级语言虚拟机（编译成汇编语言或者机器语言）</p>
<p>3.说明高级语言，汇编语言和机器语言的差别和联系？<br>高级语言：通过编译程序或者解释程序，最终转化为机器语言从而在机器上运行。<br>汇编语言：符号式的程序设计语言，每条语言对应一句机器指令（0.1）代码，所以本质上说还是面向实际机器的语言，拜托不了实际机器的指令系统。<br>机器语言：二进制代码表示的语言，编写的程序可以直接在机器上运行。<br><a id="more"></a><br>4.如何立即计算机的组成和体系结构？<br>计算机的体系结构：指的就是我们所看到系统的属性，不同的开发人员所看到的属性是不同的，例如对于高级语言开发者而言，两台型号不同的<br>机器可以看作是同一属性的机器，而对于汇编开发者来说这是两种截然不同的机器，如指令集，寻址技术得到实现都不同。<br>计算机的组成：指的是如何实现计算机体系结构所体现的属性（包含了对程序员来说透明的细节），如机器指令如何取指令，分析指令，取操作数<br>运算，送结果等。</p>
<p>5.冯.诺依曼计算机的特点是？<br>以运算器为中心，存储器，控制器，输入输出设备五大部件组成的计算机。</p>
<p>6.说出计算器赢家的主要技术指标?<br>运算速度：和机器的主频，主存本身的速度有关，现在通常用单位时间内执行的指令平均条数来衡量，MIPS作为计量单位（百万条指令每秒）<br>机器字长：计算机进行一次整数运算所能处理的二进制数据的位数，能直接影响ALU,数据总线以及存储字长的位数。<br>存储容量：主存容量是指主存中存放二进制代码的总位数，MAR的位数反应了存储单元的个数，MDR的位数反应了存储字长。</p>
<p>7.解释概念？<br>主机：通常包括 CPU、内存、硬盘、光驱、电源、以及其他输入输出控制器和接口。<br>CPU：中央处理器是一块超大规模的集成电路，含计算机运算器和控制器。它的功能主要是解释计算机指令以及处理计算机软件中的数据。<br>主存：内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁，含MDR，MAR以及存储体M。<br>存储单元：存储单元一般应具有存储数据和读写数据的功能，以8位二进制作为一个存储单元，也就是一个字节。<br>存储元，存储基元，存储元件：存储器的最小存储单元，它的作用是用来存放一位二进制代码0或1<br>存储字：存储字是指存放在一个存储单元中的二进制代码组合。可以代表二进制数，16位的二进制数，一个存储字还可代表一条指令<br>存储字长：一个存储单元存储一串二进制代码（存储字），这串二进制代码的位数称为存储字长<br>存储容量：主存容量是指主存中存放二进制代码的总位数<br>机器字长：指计算机进行一次整数运算所能处理的二进制数据的位数<br>指令字长：指令字长是指机器指令中二进制代码的总位数</p>
<p>解释英文代号：<br>CPU:中央处理器 MM:主存（内存）MAR:存储器地址寄存器 MDR:存储器数据寄存器 ALU:算数逻辑单元 X:X寄存器 ACC:累加器 MQ：乘商寄存器<br>PC:程序计数器 CU:控制单元 IR:指令寄存器</p>
<p>指令的取指，分析，执行：<br>机器启动时，控制器将PC的内容送入MAR，命令存储器做读操作，此时MDR中的命令被送至控制器的IR中，此时完成了取指过程<br>经过CU分析，指令中的地址码被推送到MAR中，并命令存储器做读操作，将该地址单元中的操作数推送到MDR中，再由MDR推送到ACC<br>与此同时PC完成加一的操作。</p>
<p>PC：用来存放当前欲执行指令的地址，和MAR存在着一条直接的通路，而且有自动加1的功能。<br>IR：用来存放当前的指令，来自MDR。<br>CU：用来分析指令，将地址码推送至MAR，并命令存储器做读操作读到MDR，然后完操作码对应的操作。</p>
<p></p><h3>系统总线</h3><br>什么是总线？总线有何特点？为了减轻总线的负载，总线上的部件应该具备什么特点？<br>计算机的总线可以划分为数据总线、地址总线和控制总线，分别用来传输数据、数据地址和控制信号<p></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CentOS-5用OpenVZ方式搭建VPN通道]]></title>
      <url>http://qianyu1996.com/2016/08/16/VPN/</url>
      <content type="html"><![CDATA[<p>最近租了个VPS，Host1Plus，0.5 Core  256MB 内存 20GB 磁盘 500GB，2美元一个月，机房在芝加哥，预装centos5系统.想尝试一下在这个VPS搭建VPN.<br>搭建方式有OpenVPN，PPTP，SSH<br>OpenVPN比PPTP好伺候，能装在基于OpenVZ虚拟化技术的VPS（PPTP只能装在基于Xen的VPS，但大多数VPS因为成本原因是OpenVZ的）<br>这里采用OpenVPN方式搭建。</p>
<p>准备工作：下载Xshell客户端，连网状态（ChinaNet等公共场合的wifi无效）</p>
<h3>一、OpenVPN需要tun和iptables_nat模块支持，所以先检查你的VPS支持不支持。</h3><br>SSH登陆VPS后输入<br><code>cat /dev/net/tun</code><br>若返回信息为：cat: /dev/net/tun: File descriptor in bad state 说明tun/tap已经可以使用；<br>如果返回：cat: /dev/net/tun: No such device 或其他则说明tun/tap没有被正确配置，发TK联系客服申请开通tun/tap。<br><a id="more"></a><br>然后检查iptables_nat模块（如果还没有安装iptables，先安装）<br><br><code>yum install iptables </code>   #如已安装跳过<br><br>接着请输入：<br><code>iptables -t nat -A POSTROUTING -s 10.168.0.0/16 -j SNAT –to-source 11.22.33.44</code><br>（11.22.33.44是你VPS的IP）<br><br>然后用<br><br><code>iptables -t nat -L</code><br>查看iptables转发状态，如果显示以下类似的结果则说明转发成功：<br>target             prot opt source                      destination<br>SNAT              all – 10.168.0.0/16                anywhere                    to:11.22.33.44<br><br><h3>二、tun和iptables_nat模块检测通过后，正式进入安装阶段：</h3><br>默认情况下CentOS的yum源是没有OpenVPN的,安装EPEL这个东西成功后,yum源里面就有OpenVPN了。<br>5.x版系统安装EPEL：<br><br><code>rpm -Uvh <a href="http://dl.fedoraproject.org/pub/epel/5/i386/epel-release-5-4.noarch.rpm" target="_blank" rel="external">http://dl.fedoraproject.org/pub/epel/5/i386/epel-release-5-4.noarch.rpm</a></code><br><br><code>yum -y install openvpn</code><br>对了，在所有步骤之前（就是刚登陆进来时），最好先更新升级下系统，这样可以自动分析当前系统的安装环境并根据具体命令网络升级安装所需组件，更便于之后组件的安装。<br><code>yum -y update</code><br><br><h3>三、安装好后，先使用easy-rsa生成服务端证书：</h3><br>默认OpenVPN的easy-rsa文档会在/usr/share/doc/openvpn/examples/easy-rsa/，如果不在的话请先检查是否安装成功然后用locate或find命令查找该文档。<br>然后将该文档下所需的配置文件复制到/etc/openvpn/下面：<br><br>如果不存在则执行：<br><code>wget <a href="http://swupdate.openvpn.org/community/releases/easy-rsa-2.2.0_master.tar.gz" target="_blank" rel="external">http://swupdate.openvpn.org/community/releases/easy-rsa-2.2.0_master.tar.gz</a></code><br><code>tar -zxvf easy-rsa-2.2.0_master.tar.gz</code><br><code>cp -R easy-rsa-2.2.0_master/easy-rsa/ /etc/openvpn/</code><br><br><br>1、生成CA证书：<br><code>cd /etc/openvpn/easy-rsa/2.0</code><br><code>source vars</code><br><code>./clean-all</code><br><code>./build-ca</code><br>期间会提示输入一些信息，直接回车默认即可。<br><br>2、生成服务器端证书和密钥：（server为服务端名字可以自定义）<br><code>./build-key-server server</code><br>期间也会提示输入一些信息，直接回车默认，选择[Y/n]的都选Y。<br><br>3、生成客户端证书和密钥：（client为客户端名字可以自定义，注意这里的客户端名字不能与上步的服务端名字相同）<br><code>./build-key client</code><br>期间也会提示输入一些信息，直接回车默认，选择[Y/n]的都选Y。<br>若要生成多个客户端的证书和密钥，将client改成另外的名字重复操作即可。所有生成的证书和密钥存都放在/etc/openvpn/easy-rsa/2.0/keys/下面。<br><br>4、生成Diffie Hellman参数：<br><code>./build-dh</code><br><h3>四、配置OpenVPN服务器端文件</h3>

<p>1、编辑/etc/openvpn/server.conf 文件，如果没有可以创建一个，加入下面的内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">local 11.22.33.44    #11.22.33.44为VPS的IP</div><div class="line">port 8080    #端口，需要与客户端配置保持一致，并保证与其他软件无共用</div><div class="line">proto udp    #使用协议，需要与客户端配置保持一致</div><div class="line">dev tun      #也可以选择tap模式</div><div class="line">ca /etc/openvpn/easy-rsa/2.0/keys/ca.crt</div><div class="line">cert /etc/openvpn/easy-rsa/2.0/keys/server.crt</div><div class="line">key /etc/openvpn/easy-rsa/2.0/keys/server.key</div><div class="line">dh /etc/openvpn/easy-rsa/2.0/keys/dh1024.pem</div><div class="line">ifconfig-pool-persist ipp.txt</div><div class="line">server 10.168.1.0 255.255.255.0    #给客户的分配的局域网IP段，注意不要与客户端网段冲突！</div><div class="line">push &amp;quot;redirect-gateway&amp;quot;</div><div class="line">push &amp;quot;dhcp-option DNS 8.8.8.8&amp;quot;</div><div class="line">push &amp;quot;dhcp-option DNS 8.8.4.4&amp;quot;</div><div class="line">client-to-client</div><div class="line">;duplicate-cn</div><div class="line">keepalive 20 60</div><div class="line">comp-lzo</div><div class="line">max-clients 50</div><div class="line">persist-key</div><div class="line">persist-tun</div><div class="line">status openvpn-status.log</div><div class="line">log-append openvpn.log</div><div class="line">verb 3</div><div class="line">mute 20</div></pre></td></tr></table></figure>
<p>3、修改/etc/sysctl.conf的内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">net.ipv4.ip_forward = 1</div><div class="line">net.ipv4.conf.all.send_redirects = 0</div><div class="line">net.ipv4.conf.default.send_redirects = 0</div><div class="line">net.ipv4.conf.all.accept_redirects = 0</div><div class="line">net.ipv4.conf.default.accept_redirects = 0</div></pre></td></tr></table></figure></p>
<p>重新载入/etc/sysctl.conf使其生效，执行如下命令：</p>
<p><code>sysctl -p</code><br>至此VPS上的服务器端配置就全部完成了。<br>若想使其配置生效，则需重启OpenVPN服务</p>
<p><code>service openvpn restart –config /etc/openvpn/server.conf</code></p>
<h3>五、安装配置OpenVPN客户端文件</h3>

<p>1、下载安装客户端<br>Windwos用户推荐去openvpn.net选择合适的版本进行安装，安装中的选项全部按默认即可；Mac用户推荐使用tunnelblick。</p>
<p>2、下载之前在VPS上生成的客户端证书及密钥<br>证书和密钥存都在/etc/openvpn/easy-rsa/2.0/keys/里，可以使用winscp链接到VPS上下载，将ca.crt、client.crt、client.key这三个文件下载到OpenVPN客户端程序的config文件夹里,默认为：C:\Program Files\OpenVPN\config<br><code>yum  install lrzsz</code><br>此时再使用sz命令下载</p>
<p>3、创建客户端配置文件<br>在C:\Program Files\OpenVPN\config 下面创建一个sunny.ovpn的文件，添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">client        #这个client不是自定义名称 不能更改</div><div class="line">dev tun       #要与前面server.conf中的配置一致。</div><div class="line">proto udp              #要与前面server.conf中的配置一致。</div><div class="line">remote 11.22.33.44 8080    #将11.22.33.44替换为你VPS的IP，端口与前面的server.conf中配置一致。</div><div class="line">resolv-retry infinite</div><div class="line">nobind</div><div class="line">persist-key</div><div class="line">persist-tun</div><div class="line">ca ca.crt              #具体名称以刚下载的为准</div><div class="line">cert client.crt              #具体名称以刚下载的为准</div><div class="line">key client.key              #具体名称以刚下载的为准</div><div class="line">ns-cert-type server</div><div class="line">redirect-gateway</div><div class="line">keepalive 20 60</div><div class="line">#tls-auth ta.key 1</div><div class="line">comp-lzo</div><div class="line">verb 3</div><div class="line">mute 20</div><div class="line">route-method exe</div><div class="line">route-delay 2</div></pre></td></tr></table></figure>
<p></p><h3>六、运行OpenVPN客户端</h3><br>运行OpenVPN GUI后，屏幕右下角的系统托盘区，会显示一个由两个红屏电脑组成的图标，右击它，选中菜单中添加的名为sunny的服务器，点击Connect，<br>过一会儿，OpenVPN图标变成绿色时VPN就表示链接成功了。就表示链接成功了~<p></p>
<p>参考原文：<a href="http://shit.name/openvpn-on-centos/" target="_blank" rel="external">http://shit.name/openvpn-on-centos/<a></a></a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM内存模型图解]]></title>
      <url>http://qianyu1996.com/2016/05/26/JVM/</url>
      <content type="html"><![CDATA[<p style="text-align: center;"><img src="http://occtjfc90.bkt.clouddn.com/1.jpg" width="70%" height="62%" alt="内存模型"></p><br><a id="more"></a><br><p style="text-align: center;"><img src="http://occtjfc90.bkt.clouddn.com/2.jpg" width="70%" height="62%" alt="内存模型"></p><br><p style="text-align: center;"><img src="http://occtjfc90.bkt.clouddn.com/3.jpg" width="70%" height="62%" alt="内存模型"></p><br><p style="text-align: center;"><img src="http://occtjfc90.bkt.clouddn.com/4.jpg" width="70%" height="62%" alt="内存模型"></p><br><p style="text-align: center;"><img src="http://occtjfc90.bkt.clouddn.com/5.jpg" width="70%" height="62%" alt="内存模型"></p><br><p style="text-align: center;"><img src="http://occtjfc90.bkt.clouddn.com/6.jpg" width="70%" height="62%" alt="内存模型"></p><br><p style="text-align: center;"><img src="http://occtjfc90.bkt.clouddn.com/7.jpg" width="70%" height="62%" alt="内存模型"></p>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java类集复习笔记]]></title>
      <url>http://qianyu1996.com/2016/05/25/leiji/</url>
      <content type="html"><![CDATA[<p></p><p style="text-align: center;"><img src="http://occtjfc90.bkt.clouddn.com/leiji.png" width="70%" height="62%" alt="内存模型"></p><p></p>
<p></p><p align="center">————上图为集合类间接口的实现关系————</p><br><a id="more"></a><p></p>
<p>1.了解java设置类集合的主要目的。<br>2.掌握Collection接口的作用和主要方法<br>3.掌握Collection子接口List Set的区别和常用子类的使用<br>4.掌握Map接口的作用，及其常用子类<br>5.SortedSet SortedMap<br>6.Iterator，Enumeration，foreach<br>7.掌握properties的使用<br>8.了解工具类Collection的使用</p>
<p>基本概念：所谓类集就是一个动态的对象数组，不受对象数组长度的限制，类集必须是<br>容易拓展和修改的。</p>
<p>Collection：public interface Collection<e> extends Iterable<e><br>toArray()将集合变成对象数组</e></e></p>
<p>List:public interface List<e> extends Collection<e><br>可以存放重复的内容<br>常用方法：add(在指定位置插入元素时，所有其他元素后移一位),addAll(),get(),indexOf(查找自定元素的位置),ListIterator(),set(替换元素)<br>remove():自定义的类如果要删除就要复写equals，hashCode方法；</e></e></p>
<p>ArrayList和Vector类比较：<br>ArrayList：新操作类，异步处理，性能好，用Iterator，foreach输出<br>Vector：旧操作类，同步处理，性能差，用Iterator，foreach，Enumeration输出<br>Vector方法是addElement</p>
<p>LinkedList：数据结构链表实现FIFO,实现了Queue和List接口<br>addFirst():在链表的开头增加元素<br>addLast():在链表的结尾增加元素</p>
<p>Set：不能存放重复的内容，所有的重复内容靠hashCode()和equals()方法区分；<br>HashSet：散列存放<br>对象删除重复需要对象复写equals方法和hashCode方法<br>代码;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public class Person1 &#123;</div><div class="line"> private String name;</div><div class="line"> private int age;</div><div class="line"></div><div class="line"> public String getName() &#123;</div><div class="line">  return name;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public void setName(String name) &#123;</div><div class="line">  this.name = name;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public int getAge() &#123;</div><div class="line">  return age;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public void setAge(int age) &#123;</div><div class="line">  this.age = age;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public String toString() &#123;</div><div class="line">  return &quot;年齡=&quot; + this.age + &quot;名字=&quot; + this.name;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public boolean equals(Object obj) &#123;</div><div class="line">  if (this == obj) &#123;</div><div class="line">   return true;</div><div class="line">  &#125;</div><div class="line">  if (!(obj instanceof Person1))</div><div class="line"></div><div class="line">  &#123;</div><div class="line">   return false;</div><div class="line">  &#125;</div><div class="line">  Person1 p = (Person1) obj;</div><div class="line">  if (this.name.equals(p.name) &amp;&amp; this.age == this.age) &#123;</div><div class="line">   return true;</div><div class="line">  &#125; else &#123;</div><div class="line">   return false;</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public int hashCode() &#123;</div><div class="line">  return this.name.hashCode() * this.age;</div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>TreeSet:有序排列<br>对象删除重复需要每个对象都实现Comparable接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class Person implements Comparable&lt;Person&gt; &#123;</div><div class="line"> private String name;</div><div class="line"> private int age;</div><div class="line"></div><div class="line"> public String getName() &#123;</div><div class="line">  return name;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public void setName(String name) &#123;</div><div class="line">  this.name = name;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public int getAge() &#123;</div><div class="line">  return age;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public void setAge(int age) &#123;</div><div class="line">  this.age = age;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public String toString() &#123;</div><div class="line">  return &quot;年齡=&quot; + this.age + &quot;名字=&quot; + this.name;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public int compareTo(Person o) &#123;</div><div class="line">  if (this.age &gt; o.getAge()) &#123;</div><div class="line">   return 1;</div><div class="line">  &#125; else if (this.age &lt; o.getAge()) &#123;</div><div class="line">   return -1;</div><div class="line">  &#125; else &#123;</div><div class="line"></div><div class="line">   return this.name.compareTo(o.name);</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Queue：队列接口<br>peek（）：找到头结点<br>poll（）找到头节点并删除<br>element（）找到链表的表头</p>
<p>SortedSet：对集合中的数据进行排序</p>
<p>Iterator:迭代输出，是使用最多的输出方式<br>ListIterator:是Iterator的子接口，专门用于list集合输出，双向输出<br>Enumeration:旧接口，功能与Iterator类似<br>foreach:可以输出数组或者集合，jdk1.5之后的功能</p>
<p>Iterator：<br>Iterator it = list.iterator();<br>方法：hasNext();是否有下一个值<br>       next();输出当前元素<br>       remove();删除当前元素</p>
<p> 注意点：<br> 一个集合把内容交给迭代器删除时候，因为集合也有remove方法，删除的时候调用<br> 了自身的删除方法，迭代器就会出现运行时错误（因为集合本身被破坏掉，所以迭代器<br> 就会中止迭代出现错误）<br> remove之前必须要执行it.next指向该元素，否则会出现异常</p>
<p> ListIterator<br> 如果想完成双向输出，则首先要完成由前向后的输出。  </p>
<p> Enumeration：<br> 无删除操作，类似于Iterator<br> 想要实现此接口只能通过Vector类elements方法</p>
<p>Map</p>
<p>HashMap：无序存放，key不允许重复，key可以为null<br>Hashtable：无需存放，旧的操作类，key不允许重复，key不可null<br>TreeMap:可以排序的Map集合，按照key排序，不允许重复<br>WeakTreeMap：弱引用Map集合，不在使用某些内容时gc回收<br>IdentityHashMap：key可以重复的Map集合</p>
<p>Map：<br>keySet（）方法，可以将所有的key变成一个Set集合<br>values（）方法返回Collection对象，得到所有value值</p>
<p>TreeMap 按照key排序<br>对象实现comparable接口</p>
<p>Map迭代：<br>1.将Map接口的实例通过entrySet（）方法变成Set接口对象<br>2.通过set接口实例为Iterator实例化<br>3.迭代输出每个对象都是Map.Entry对象<br>4.通过Map.Entry进行key–value的分离</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line">import java.util.Iterator;</div><div class="line">import java.util.Map;</div><div class="line">import java.util.Map.Entry;</div><div class="line">import java.util.Set;</div><div class="line"></div><div class="line">public class Test &#123;</div><div class="line"></div><div class="line"> public static void main(String[] args) &#123;</div><div class="line">  Map&lt;String,String&gt; m=new HashMap&lt;String,String&gt;();</div><div class="line">        m.put(&quot;hah0&quot;, &quot;heh0&quot;);</div><div class="line">        m.put(&quot;hah1&quot;, &quot;heh1&quot;);</div><div class="line">        m.put(&quot;hah2&quot;, &quot;heh2&quot;);</div><div class="line">        m.put(&quot;hah3&quot;, &quot;heh3&quot;);</div><div class="line">        m.put(&quot;hah4&quot;, &quot;heh4&quot;);</div><div class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; s = m.entrySet();</div><div class="line">       Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it =s.iterator();</div><div class="line">      while(it.hasNext())&#123;</div><div class="line">      Map.Entry&lt;String, String&gt; me =it.next();</div><div class="line">       System.out.println(me.getKey()+me.getValue());</div><div class="line">       </div><div class="line">   </div><div class="line">      &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果要使用自己的匿名類作為key，則必須要复写其类中的equals和hashCode方法</p>
<p>SortedMap：<br>同SortedSet类似的原理</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面向对象四大设计原则]]></title>
      <url>http://qianyu1996.com/2016/05/24/yuanze/</url>
      <content type="html"><![CDATA[<p></p><h1>面向抽象原则</h1><p></p>
<p></p><h2>1.1 抽象类</h2><br>特点：<br>        1.抽象类中的abstract方法可有可无，也可以有非abstract方法<br>        2.抽象类不能用new创建对象<br>        3.抽象类的非抽象子类必须重写父类的abstract方法<br>        4.作为向上转型对象。抽象类不能创建对象，但可以让抽象类的对象成为其非抽象子类的向上转型对象，调用子类的方法<br>        <a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">abstract class A &#123;  </div><div class="line">    public abstract int add(int x,int y);  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">class B extends A &#123;  </div><div class="line">    public int add(int x, int y) &#123;  </div><div class="line">        return x+y;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">public class App &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        A a = new B();  </div><div class="line">        System.out.println(a.add(3, 4));  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h2>1.2 接口</h2><br>特点：<br>        1.接口中只能有public权限的abstract方法，不能有非abstract方法<br>        2.接口由类去实现，并且必须重写接口中的abstract方法<br>        3.接口回调。把实现接口的类的对象的引用赋给该接口声明的接口变量，那么此接口变量就可以调用被类实现的接口中的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">interface Com &#123;  </div><div class="line">    public abstract int sub(int x,int y);  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">class ComImp implements Com &#123;  </div><div class="line">    public int sub(int x, int y) &#123;  </div><div class="line">        return x-y;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">public class App &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        Com com = new ComImp();  </div><div class="line">        System.out.println(com.sub(3, 4));  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p></p><h2>1.3 面向抽象</h2><br> 所谓面向抽象编程，就是指当设计一个类时，不该让类面向具体的类，而是面向抽象类或接口，即所设计的类中的重要数据是抽象类或接口声明的变量，而不是具体声明的变量。<br>        例如，现在有一个Circle类，有一个getArea()方法计算圆的面积：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Circle &#123;  </div><div class="line">    double r;  </div><div class="line">    Circle(double r) &#123;  </div><div class="line">        this.r = r;  </div><div class="line">    &#125;  </div><div class="line">    public double getArea() &#123;  </div><div class="line">        return(3.14*r*r);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p> 现在要设计一个Pillar类（柱体类），有一个getVolume方法计算体积<br>Pillar.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Pillar &#123;  </div><div class="line">    Circle bottom;  //将Circle对象作为成员  </div><div class="line">    double height;  </div><div class="line">    public Pillar(Circle bottom, double height) &#123;  </div><div class="line">        this.bottom = bottom;  </div><div class="line">        this.height = height;  </div><div class="line">    &#125;  </div><div class="line">    public double getVolume() &#123;  </div><div class="line">        return bottom.getArea()*height;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 现在来分析Pillar类，bottom是用具体类Circle类声明的变量，若用户需求不变化，则Pillar类可以这样设计。但如果用户希望求底是三角形的柱体的体积，显然上述Pillar类不能应对这种需求。<br>        因此需要重新设计Pillar类，这时不需要关心底是什么形状，而应该关心底是否有计算面积的方法。所以底不应该是某个具体类声明的变量，这样才能应对不同的需求。<br>接下来重新设计PIllar类。 首先设计一个抽象类（或接口）Geometry(几何)，有一个抽象的getArea()方法。<br>Geometry.java<br><code>public abstract class Geometry {<br>    public abstract double getArea();<br>}  </code></p>
<p>这样设计以后，Pillar类就不再依赖具体类，而是面向Geometry类，即Pillar类中的bottom是抽象类Geometry声明的变量。<br>Pillar.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Pillar &#123;  </div><div class="line">    Geometry bottom;    //bottom是抽象类Geometry声明的变量  </div><div class="line">    double height;  </div><div class="line">    public Pillar(Geometry bottom, double height) &#123;  </div><div class="line">        this.bottom = bottom;  </div><div class="line">        this.height = height;  </div><div class="line">    &#125;  </div><div class="line">    public double getVolume() &#123;  </div><div class="line">        return bottom.getArea()*height;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来就是让Circle和Rectangle（矩形）继承抽象类Geometry，并重写getArea()方法。<br>Circle.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Circle extends Geometry  &#123;  </div><div class="line">    double r;  </div><div class="line">    Circle(double r) &#123;  </div><div class="line">        this.r = r;  </div><div class="line">    &#125;  </div><div class="line">    public double getArea() &#123;  </div><div class="line">        return(3.14*r*r);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">public class Rectangle extends Geometry &#123;  </div><div class="line">    double length;  </div><div class="line">    double width;  </div><div class="line">    public Rectangle(double length, double width) &#123;  </div><div class="line">        this.length = length;  </div><div class="line">        this.width = width;  </div><div class="line">    &#125;  </div><div class="line">    public double getArea() &#123;  </div><div class="line">        return length*width;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 现在就可以用Pillar创建具有矩形底或圆形底的柱体了。<br>App.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class App &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        Pillar pillar;  </div><div class="line">        Geometry bottom;  </div><div class="line">          </div><div class="line">        bottom = new Rectangle(100, 50);  </div><div class="line">        pillar = new Pillar(bottom, 50);  </div><div class="line">        System.out.println(&quot;矩形底的柱体的体积：&quot; + pillar.getVolume());  </div><div class="line">          </div><div class="line">        bottom = new Circle(50);  </div><div class="line">        pillar = new Pillar(bottom, 50);  </div><div class="line">        System.out.println(&quot;圆形底的柱体的体积：&quot; + pillar.getVolume());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过面向抽象来设计Pillar类，使得Pillar类不再依赖具体类，因此每当系统增加Geometry的子类时，比如增加一个Triabgle子类，<br>那么不需要修改Pillar类的任何代码，就可以使用Pillar创建出具有三角形底的柱体。</p>
<p></p><h1>2. 开-闭原则</h1><br>所谓“开-闭原则“（Open-Closed Principle）就是让设计对扩展开放，对修改关闭。本质就是指当一个设计中增加新的模块时，不需要修改现有的模<br>块。在给出一个设计时，应当首先考虑到用户需求的变化，将最有可能变化的部分设计为对扩展开放，而设计的核心部分是精心考虑后确定下来的，应该<br>对修改关闭，即不能因为用户需求的改变而修改。<p></p>
<p></p><h1>3. 多用组合少用继承原则</h1><p></p>
<p></p><h2>3.1 继承与复用</h2><br>子类通过继承父类可以复用父类的方法<br>优点：<br>        1.子类在需要的时候可以重写父类的方法，易于修改或扩展那些被复用的方法<br>缺点：<br>        1.无法在运行期间改变从父类继承的方法的行为<br>        2.继承是强耦合的关系，即当父类的方法的行为改变时，必然导致子类相应方法改变<br>        3.通过继承复用也称为“白盒”复用，这样就是说父类的内部细节对于子类而言是可见的        <p></p>
<p></p><h2>3.2 组合与复用</h2><br>一个类将其它对象作为自己的组成部分，即Has-A，这样就可以通过委托其它对象调用其方法来达到复用的目的。<br>优点：<br>        1.组合复用称为“黑盒”复用，即当前对象对所包含对象的具体细节是不可见的<br>        2.组合是弱耦合的关系，即修改所包含的对象的类的代码，不必修改当前类的代码<br>        3.当前对象可以在运行时动态指定所包含的对象<br>缺点：<br>        1.导致系统中对象过多<br>        2.要组合多个对象时，必须仔细地对接口进行定义<p></p>
<p></p><h1>4. 高内聚-低耦合原则</h1><br> 高内聚：类中的方法是一组相关的行为<br> 低耦合：尽量不要让一个类含有太多其它类的实例引用，以避免“牵一发而动全身”<p></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[反射机制复习笔记]]></title>
      <url>http://qianyu1996.com/2016/05/24/reflect/</url>
      <content type="html"><![CDATA[<p>1.了解反射的基本原理<br>2.掌握class类的使用<br>3.使用Class类并结合java.lang.reflect包取得一个类的完整结构<br>4.通过反射机制动态的调用类中指定的方法，并能向这些方法中传递参数<br><a id="more"></a></p>
<p>核心概念：一切的操作都将使用object进行完成，包括类，数组的应用都可以用object进行接收。</p>
<p>正常方式：引入包.类–通过new实例化对象–获取实例化对象<br>反射方式：获得实例化对象–getClass（）方法获得Class实例–得到完整的包.类名称</p>
<p>java.lang.Class是java.lang.Object的派生类，前者继承自后者。<br>在java中Object类是一切类的父类，那么所有对象实际上<br>也就是java.lang.Class类的实例，所以所有对象都可以转变为java.lang.Class类型表示。</p>
<p>实例化Class类对象：Class.forName（），类.class，对象.getClass（）;</p>
<p>用Class类对象本身实例化其他对象:<br>对象无参:用newInstance方法;<br>对象有参数:Constructor&lt;?&gt; con[] =Class.forName(“com.evan.reflect.Person2”).getConstructors();<br>调用Class实例的getConstrcuctors获得一个Constructor数组，再使用Constructor对象的newInstance()方法<br>实例化其他对象。得到的Object再进行向下转型。</p>
<p>取得类结构：<br>Constuctors表示类中的构造方法；<br>Field表示类中的属性；<br>Method表示类中的方法；<br>这三个都是AccessibleObject的子类它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力</p>
<p>得到接口：Class&lt;?&gt;[] f = c.getInterfaces();<br>得到构造方法：Constructor&lt;?&gt;[] cons = c.getConstructors();（可直接打印出来）<br>构造方法拆分获得：<br>···<br>Constructor&lt;?&gt;[] cons = c.getConstructors();<br>for (int i = 0; i &lt; cons.length; i++) {<br>System.out.println(Modifier.toString(cons[i].getModifiers()));//把int变为权限修饰符<br>System.out.println(cons[i].getName());//获得方法名<br>Class&lt;?&gt;[] b = cons[i].getParameterTypes();//获得参数<br>for (int j = 0; j &lt; b.length; j++) {<br>System.out.print(b[j].getName() + “ arg” + i);<br>if (j &lt; b.length - 1) {<br>System.out.print(“,”);<br>} else {<br>System.out.println(“){}”);<br>}<br>}<br>} ···</p>
<p>得到父类：getSuperclass();<br>得到方法：Method[] m = c.getMethods();（可直接打印出来）<br>得到方法的返回值类型,异常类型： m[i].getReturnType().getName();<br>                                       Class&lt;?&gt;[] ex =m[i].getExceptionTypes();<br>                              ex[i].getName();<br>得到实现的接口或父类中的公共属性：public Field[] getFileds();<br>                                      f[i].getModifiers(访问权限)/getName(属性名)/getType(属性类型);<br>得到本类中的全部属性： public Filed[] getDeclaredFields();<br>                             f[i].getModifiers(访问权限)/getName(属性名)/getType(属性类型);</p>
<p>通过反射访问类中的方法。<br>···<br> Class&lt;?&gt; c=Class.forName(“……”);<br> Object obj = c.newInstance();<br> Method med = c.getMethod(“setCountry”,String.class);<br> med.invoke(obj,”haha”);</p>
<p>setter getter 反射实现：<br>class GetClassDemo6 {<br>public static void main(String[] args) {<br>Object per = null;<br>try {<br>per =Class.forName(“com.evan.reflect.Person4”).newInstance();<br>} catch (InstantiationException e) {<br>e.printStackTrace();<br>} catch (IllegalAccessException e) {</p>
<p>e.printStackTrace();<br>} catch (ClassNotFoundException e) {</p>
<p>e.printStackTrace();<br>}<br>setter(per, “name”, “sb”, String.class);<br>setter(per, “age”, 30, int.class);<br>getter(per, “name”);<br>getter(per, “age”);<br>}</p>
<p>public static void setter(Object obj, String arr, Object value, Class&lt;?&gt; type) {</p>
<p>try {<br>String s =”set”+up(arr);<br>Method met = obj.getClass().getMethod(s, type);<br>met.invoke(obj, value);<br>} catch (NoSuchMethodException e) {<br>// TODO Auto-generated catch block<br>e.printStackTrace();<br>} catch (SecurityException e) {<br>// TODO Auto-generated catch block<br>e.printStackTrace();<br>} catch (IllegalAccessException e) {<br>// TODO Auto-generated catch block<br>e.printStackTrace();<br>} catch (IllegalArgumentException e) {<br>// TODO Auto-generated catch block<br>e.printStackTrace();<br>} catch (InvocationTargetException e) {<br>// TODO Auto-generated catch block<br>e.printStackTrace();<br>}<br>}</p>
<p>public static void getter(Object obj, String arr) {<br>try {<br>String s =”get”+up(arr);<br>Method met = obj.getClass().getMethod(s);<br>System.out.println(met.invoke(obj));<br>} catch (NoSuchMethodException e) {<br>// TODO Auto-generated catch block<br>e.printStackTrace();<br>} catch (SecurityException e) {<br>// TODO Auto-generated catch block<br>e.printStackTrace();<br>} catch (IllegalAccessException e) {<br>// TODO Auto-generated catch block<br>e.printStackTrace();<br>} catch (IllegalArgumentException e) {<br>// TODO Auto-generated catch block<br>e.printStackTrace();<br>} catch (InvocationTargetException e) {<br>// TODO Auto-generated catch block<br>e.printStackTrace();<br>}</p>
<p>}</p>
<p>public static String up(String arr) {<br>String s = arr.substring(0, 1).toUpperCase() + arr.substring(1);<br>return s;<br>}<br>} ···</p>
<p>反射操作数组：<br>得到数组Class类型：Class&lt;?&gt; c = temp.getClass().getComponentType();<br>修改数组大小：<br>···<br>public static void main(String[] args) {<br>int temp[] = { 1, 2, 3 };<br>// Class&lt;?&gt; c = temp.getClass().getComponentType();//获得数组组件类型的 Class<br>// System.out.println(c.getName());//返回数组类型<br>int temp1[] = (int[]) arrayinc(temp, 5);<br>for (int i = 0; i &lt; temp1.length; i++) {<br>System.out.println(temp1[i]);<br>}<br>} ···<br>···<br>public static Object arrayinc(Object obj, int len) {<br>Class&lt;?&gt; c = obj.getClass();<br>Class&lt;?&gt; a = c.getComponentType();<br>Object Onew = Array.newInstance(a, len);<br>int co = Array.getLength(obj);<br>System.arraycopy(obj, 0, Onew, 0, co);<br>//源数组对象，从源下标位置开始，新数字，从新下标位置开始，复制源数组长度<br>return Onew;<br>} ···</p>
<p>Array类反射操作包中表示一个数组<br>Array.newInstance(a, len);新建一个数组，a表示任意数组组件类型的 Class对象<br>Array.getLength(obj);得到数组长度<br>Array.set(Object array，int index，int value);修改制定下标的内容</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端-原生Ajax理解]]></title>
      <url>http://qianyu1996.com/2016/05/20/ajax/</url>
      <content type="html"><![CDATA[<p>前言： 这两天在做一个人日记网站，基于前端+Servlet+JSP+JavaBean+tomcat+mysql实现，由于之前的实践很少碰到前端内容，这次自己搞也是边学边弄，到了js这块，必不可少的就是Ajax技术，博主花了一些时间去学习了一下，并做点总结。</p>
<p></p><h2 color="red">什么是Ajax?</h2><br><a id="more"></a><br>简单地说，如果你访问一个没有用到Ajax技术的网页，通常你点一下按钮就要刷新一下页面，尽管新页面上只有一行字和当前页面不一样，但你还是要无聊地等待页面刷新。用了AJAX之后，你点击，然后页面上的一行字就变化了，页面本身不用刷新。<br>Ajax的应用：<br>百度搜索提示，淘宝新会员注册时用户名验证，级联下拉列表，显示进度条……<p></p>
<p>补充一下下面的内容（摘录自知乎）：<br>ajax的全称是AsynchronousJavascript+XML。<br>异步传输+js+xml。<br>所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果我们可以再来处理这个事。（当然，在其他语境下这个解释可能就不对了）<br>这个很重要，如果不是这样的话，我们点完按钮，页面就会死在那里，其他的数据请求不会往下走了。这样比等待刷新似乎更加讨厌。<br>（虽然提供异步通讯功能的组件默认情况下都是异步的，但它们也提供了同步选项，如果你好奇把那个选项改为false的话，你的页面就会死在那里）<br>xml只是一种数据格式，在这件事里并不重要，我们在更新一行字的时候理论上说不需要这个格式，但如果我们更新很多内容，那么格式化的数据可以使我们有条理地去实现更新。</p>
<p></p><h2 color="green">过程及代码</h2><br>其实在博主的脑袋里，Ajax就是一个超级有用的XMLHttpRequest对象啦，ajax就可以让js读取服务器上的数据。<br>那么首先你要创建出这个对象了咯，一般来说，Ajax的使用就像打电话一样分为四步：<br>1.你得有个手机。<br>2.拨号。<br>3.你开始说话balabala。。。<br>4.听别人说。。。。<p></p>
<p>那么Ajax：<br>1.创建Ajax对象。<br>2.连接到服务器。<br>3.发送请求。<br> 4.接受返回值。</p>
<p>1.创建Ajax对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">if (window.XMLHttpRequest) &#123; // Mozilla……等非IE浏览器</div><div class="line">var oAjax = new XMLHttpRequest(); // 创建XMLHttpRequest对象</div><div class="line">&#125; else if (window.ActiveXObject) &#123; // IE浏览器</div><div class="line">try &#123;</div><div class="line">var oAjax = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); // 创建XMLHttpRequest对象</div><div class="line">&#125; catch (e) &#123;</div><div class="line">try &#123;</div><div class="line">var oAjax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); // 创建XMLHttpRequest对象</div><div class="line">&#125; catch (e) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每个浏览器对Ajax的支持是不同的，创建的方式也不同，以上判断代码就展示了在IE浏览器和非IE浏览器环境下用各自不同的方式创建XMLHttpRequest对象。<br>这里要注意一下js的一个特性，在使用判断时必须使用window.XMLHttpRequest而不能使用XMLHttpRquest,在js中用没有定义的变量会报错，使用没有定义的属性不会报错，而是仅仅给你一个undefined提示，在IE6浏览器下，XMLHttpRequest是没有定义的，考虑到兼容性问题，必须使用window.XMLHttpRequest来充当判断条件，这时浏览器就把它当window的一个属性，返回undefined而非报错，这就是我们需要的。</p>
<p>2.连接到服务器。</p>
<p><code>oAjax.open();</code><br>open()有三个参数，第一个参数为发送方式，值为POST，GET<br>第二个参数为你要访问的文件的url。<br>第三个为 值为true 或者 false ，true代表采用异步传输方式连接服务器。</p>
<p>3.发送请求<br><code>oAjax.send();</code></p>
<p>4 .接受返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">funtion getResult()&#123;</div><div class="line">if(oAjax.readyState==4)&#123;</div><div class="line">      if(oAjax.status==200)&#123;</div><div class="line">                            alert(oAjax.reponseText);</div><div class="line">                            &#125;else&#123;alert(&quot;访问失败&quot;);&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>readyState的值所代表的状态：<br>0：请求未初始化（还没有调用 open()）。<br>1：请求已经建立，但是还没有发送（还没有调用 send()）。<br>2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。<br>3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。<br>4：响应已完成；您可以获取并使用服务器的响应了。<br>       status的值所代表的状态（最常见的5种）：<br>       1.200表示成功<br>       2.202表示请求被接受，但尚未成功<br>       3.400错误的请求<br>       4.404文件未找到<br>       5.500内部服务器错误</p>
<p>四部曲完成了，为了提高的代码重用性，可以将代码封装到一个.js文件中，代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">var net = new Object(); // 定义一个全局变量net</div><div class="line">// 编写构造函数</div><div class="line">net.AjaxRequest = function(url, onload, onerror, method, params) &#123;</div><div class="line">this.req = null;</div><div class="line">this.onload = onload;</div><div class="line">this.onerror = (onerror) ? onerror : this.defaultError;</div><div class="line">this.loadDate(url, method, params);</div><div class="line">&#125;</div><div class="line">// 编写用于初始化XMLHttpRequest对象并指定处理函数，最后发送HTTP请求的方法</div><div class="line">net.AjaxRequest.prototype.loadDate = function(url, method, params) &#123;</div><div class="line">if (!method) &#123; // 设置默认为的请求方式为GET</div><div class="line">method = &quot;GET&quot;;</div><div class="line">&#125;</div><div class="line">if (window.XMLHttpRequest) &#123; // Mozilla……等非IE浏览器</div><div class="line">this.req = new XMLHttpRequest(); // 创建XMLHttpRequest对象</div><div class="line">&#125; else if (window.ActiveXObject) &#123; // IE浏览器</div><div class="line">try &#123;</div><div class="line">this.req = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); // 创建XMLHttpRequest对象</div><div class="line">&#125; catch (e) &#123;</div><div class="line">try &#123;</div><div class="line">this.req = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); // 创建XMLHttpRequest对象</div><div class="line">&#125; catch (e) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">if (this.req) &#123;</div><div class="line">try &#123;</div><div class="line">var loader = this;</div><div class="line">// 指定回调函数</div><div class="line">this.req.onreadystatechange = function() &#123;</div><div class="line">net.AjaxRequest.onReadyState.call(loader);</div><div class="line">&#125;</div><div class="line">this.req.open(method, url, true); // 创建与服务器的连接</div><div class="line">if (method == &quot;POST&quot;) &#123; // 当发送POST请求时，设置请求头</div><div class="line">this.req.setRequestHeader(&quot;Content-Type&quot;,</div><div class="line">&quot;application/x-www-form-urlencoded&quot;);</div><div class="line">&#125;</div><div class="line">this.req.send(params); // 向服务器发送请求</div><div class="line">&#125; catch (err) &#123;</div><div class="line">this.onerror.call(this); // 调用错误处理函数</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 重构回调函数</div><div class="line">net.AjaxRequest.onReadyState = function() &#123;</div><div class="line">var req = this.req;</div><div class="line">var ready = req.readyState; // 获取请求状态</div><div class="line">if (ready == 4) &#123;</div><div class="line">if (req.status == 200) &#123;</div><div class="line">this.onload.call(this); // 调用回调函数</div><div class="line">&#125; else &#123;</div><div class="line">this.onerror.call(this); // 调用错误处理函数</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// 重构默认的错误处理函数</div><div class="line">net.AjaxRequest.prototype.defaultError = function() &#123;</div><div class="line">alert(&quot;错误数据\n\n回调状态:&quot; + this.req.readyState + &quot;\n状态: &quot; + this.req.status);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
